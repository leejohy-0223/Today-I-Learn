# 스프링 삼각형과 설정 정보

### 개요
- 스프링을 이해하는 데는 POJO(Plain Old Java Object)를 기반으로 스프링 삼각형이라는 애칭을 가진 다음 3가지에 대한 이해가 필수이다.
    - IoC / DI
    - AOP
    - PSA(Portable Service Abstraction) : 일관성 있는 서비스 추상화
    
<br><br>    
### 1. IoC/DI - 제어의 역전 / 의존성 주입
- 알아보기 전에 프로그래밍에서의 의존성이란 무엇일까?
    - pseudo code 
        - 운전자가 자동차를 생산한다.
        - 자동차는 내부적으로 타이어를 생산한다.
    - Java로 표현
        - 운전자 안에서 new Car();
        - Car 생성자 내에서 new Tire();
    - 의존성 정의
        - 의존성은 new이다.
        - new를 실행하는 Car와 Tire 사이에서 Car가 Tire에 의존한다.
    

- 즉, 전체가 부분에 의존한다. 그리고 프로그래밍에서 의존 관계는 new로 표현된다고 우선 기억하자.
- expert001_01에서, 다음과 같이 의존관계를 형성했다.
    1. Driver에서 new Car를 통해 자동차 직접 생산
    2. Car에서 new KoreaTire를 통해 타이어 직접 생산(구체화)

<br><br>
#### 1) 스프링 없이 의존성 주입하기 1 - 생성자를 통한 의존성 주입 (pkg : expert001_02)
- 주입이란, 외부에서 생성된 객체를 전달하는 것을 의미한다. 즉, 외부에서 생산되는 타이어를 자동차에 장착하는 과정이 주입이다.
- 외부에서 생산된 Tire 객체를 Car 생성자의 인자로 주입(장착)하는 형태로 구현해보자. 즉 Driver에서 타이어를 생산하여, Car 생성자의 인자 주입으로 해결한다.
- Tire는 더 이상 한국 타이어, 미국 타이어를 직접 생성할 필요 없다. 새로운 타이어 브랜드가 생겨도 Driver에서 주입해주면 된다.
- 여기에는 전략 패턴이 응용되었다.
     - 전략 : Tire 구현체
     - 컨텍스트 : Car의 getTireBrand 메서드
     - 클라이언트 : Driver의 main에서 전략을 생성 후 컨텍스트에 주입하여 그에 맞는 메서드를 실행한다.
    
<br><br>
#### 2) 스프링 없이 의존성 주입하기 2 - 속성을 통한 의존성 주입 (pkg : expert001_03)
- 앞서 생성자 방식은, 한번 타이어 장착 후 변경할 수 없다는 점이다. 더 현실적인 방법은 운전자가 원할 때 Car의 Tire를 교체하는 것이다.
- 대부분 속성을 통한 의존성 주입을 선호하며, 스프링에서는 애노테이션을 사용하는 경우 주로 속성 주입을 사용하게 된다.. 필드 주입을 의미하는 건가?
- 속성 주입은 setter 주입 & 필드 주입을 의미하는 걸로 보인다. 
- 개발자에 따라 다르겠지만, 불변 & 누락을 고려해서 생성자 주입을 활용하도록 하자.


<br><br>
#### 3) 스프링을 통한 의존성 주입 - xml 사용
- 스프링을 사용하면, 생성을 모두 스프링 프레임워크에 맡기게 된다. 
- xml 설정 파일을 만들고, 빈을 직접 등록한 후 Application context를 만들고, 여기에서 getBean을 통해 Car, Tire 등을 가져올 수 있다.
- xml property를 통해, setter도 호출이 가능하다.
- 실습은 생략했다.


<br><br>
#### 4) 스프링을 통한 의존성 주입 - @Autowired를 통한 속성 주입
- Setter 없이 필드에 @Autowired 어노테이션을 작성함으로써 속성을 주입 받을 수 있다.

#### 변경된 Car.java
```java
@Component
public class Car {

    private final Tire tire;

    @Autowired
    public Car(@Qualifier("tire1") Tire tire) {
        this.tire = tire;
    }

    public String getTireBrand() {
        return "장착된 타이어: " + tire.getBrand();
    }
}
```
#### 변경된 KoreaTire.java
```java
@Component
@Qualifier(value = "tire1")
public class KoreaTire implements Tire {
    @Override
    public String getBrand() {
        return "코리아 타이어";
    }
}
```
#### 변경된 Driver.java
```java
@Component
public class Driver {

    private final Car car;

    @Autowired
    public Driver(Car car) {
        this.car = car;
    }

    public String brandName() {
        return car.getTireBrand();
    }
}
```
- 이전과 다른 점은, @Component를 붙여 스프링 부트에서 자동으로 스캔하도록 설정한 점이다. xml 또는 config 방식에서는 ApplicationContext를 만들어, getBean으로 가져왔어야 했다.
- @Qualifier는 스캔된 빈이 여러개일 때 해당 이름이 붙은 빈을 주입해준다. 여기서 또 의존관계가 발생하는게 아닌지??(Car에 직접 name으로 빈을 지정하므로)


#### DriverTest.java
```java
@SpringBootTest
class DriverTest {

    @Autowired
    private Driver driver;

    @Test
    void 브랜드네이밍_테스트() {
        Assertions.assertEquals("장착된 타이어: 미국 타이어", driver.brandName());
    }
}
```
- Junit5부터는 테스트에 @RunWith를 생략할 수 있다.
- 또한 @SpringBootTest 내에 @ExtendWith(SpringExtension.class)이 존재한다.
- 스프링 프레임워크를 통해 driver를 주입받아서 테스트로 활용 가능하다.

#### DI 마무리
- 변수에 값을 할당하는 모든 곳에 의존관계는 발생한다. DI는 외부에 있는 의존 대상을 주입하는 것을 말한다.
- 의존 대상을 구현하고 배치할 때 SOLID, 응집도는 높이고, 결합도는 낮추라는 기본 원칙에 충실해야 한다.


<br><br>    
### 2. AOP - Aspect(관점 / 핵심 관심사)





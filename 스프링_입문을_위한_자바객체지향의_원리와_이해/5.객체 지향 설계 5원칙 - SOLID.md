# 객체 지향 설계 5원칙(SOLID)

### 개요
- 객체 지향 언어를 이용해 객체 지향 프로글매을 올바르게 설계해 나가는 방법 & 원칙


- 객체 지향 5원칙은 다음과 같다.
    - SRP(Single Responsibility Principle) : 단일 책임 원칙
    - OCP(Open Closed Princlple) : 개방 폐쇄 원칙
    - LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
    - ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
    - DIP(Dependency Inversion Principle) : 의존 역전 원칙
    

- 해당 원칙은 응집도를 높이고(High Cohesion), 결합도는 낮추라는(Loose Coupling) 고전 원칙을 객체 지향 관점에서 재정립한 것이다.
    - 결합도 : 모듈(클래스) 간의 상호 의존 정도로서 결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용, 수정, 유지보수 용이하다.
    - 응집도 : 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성으로, 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용, 기능 수정, 유지보수가 용이하다.
    

- SOLID는 객체 지향 4대 특성(캡슐화, 상속, 추상화, 다형성)을 발판으로 하고 있으며, 디자인 패턴의 뼈대이고 스프링 프레임워크의 근간이 된다.
<br><br>

### 1. SRP : 단일 책임 원칙 

- 하나의 클래스에 의존하는 다양한 클래스에 대해서, 각각의 역할(책임)로 분리하는 것을 의미한다.
- 하나의 프로퍼티가 여러 의미를 갖는 것도 SRP를 지키지 못한 것이다.
- 하나의 메서드가 SRP를 지키지 않을 경우, 대표적으로 분기 처리를 위한 if문이 발생한다.
- 이와 같이 SRP는 클래스의 분할 뿐 아니라 프로퍼티, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크에도 적용할 수 있다.
- 객체 지향 4대 특성 중, 모델링을 담당하는 추상화와 연관이 있다.


### 2. OCP : 개방 폐쇄 원칙

- 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
  

- 운전자 - 자동차 모델을 고려한다.
    - 운전자는 자동차의 차종(마티즈, 소나타)에 의존하여 기어조작 메서드를 따로 호출하는 건 OCP에 위반된다.
    - 따라서, 운전자와 차종 사이에 '자동차'라는 인터페이스를 두고, 차종이 각각 이를 구현하게 함으로써 OCP를 지킬 수 있다.
    - 운전자 입장에서는 주변의 변화에 닫혀있고, 자동차 입장에서는 차종(확장)에 열려있으므로 OCP를 지킨다는 의미이다.
    

- 자바에도 OCP가 적용되어 있다.
    - 자바 개발자는 본인 PC에 설치된 JVM에서 구동되는 소스 코드를 작성한다.
    - 이 소스코드는 OS의 변화에 닫혀있으며, 각 OS별 JVM은 확장에 열려있게 된다.
    - 이 중간에는 'object file(.class)'이라는 완충 장치가 있는 것이다.
    

### 3. LSP : 리스코프 치환 원칙 

- 서브 타입은 언제나 자신의 기반(base type)으로 교체할 수 있어야 한다.


- 객체 지향에서의 상속은 조직도 / 계층도가 아닌, 분류도가 되어야 한다. 상속은 이를 만족한다.
    - 하위 클래스 is a kind of 상위 클래스 - 하위 클래스는 상위 클래스의 한 종류이다.
    - 구현 클래스 is able to 인터페이스 - 구현 클래스는 인터페이스할 수 있어야 한다.
    

- 위를 만족하지 못한 경우는, 바로 상속이 조직도 / 계층도 형태로 구축된 경우이다. 
    - 조직 / 계층 형태의 잘못된 예시 
         - 아버지 a = new 딸(); -> 딸에게 아버지의 역할을 부여한다?
    - 분류도 형태의 옳은 예시 
         - 동물 a = new 펭귄(); -> 펭귄에게 동물의 역할(숨쉬기 등)을 부여할 수 있다. 
    

- 즉, 하위 클래스의 인스턴스(펭귄)는 상위형 객체 참조 변수(동물)에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.


- 결국 LSP는 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻어진다. 


- 단순히 컴파일 성공 측면에서가 아닌, 기능적으로 상위 클래스(인터페이스)의 기능을 올바르게 구현해야 한다.


### 4. ISP : 인터페이스 분리 원칙

- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.


- SRP와 같이 클래스를 단일 책임으로 분리할 수 있는 방법도 있고, ISP를 활용할 수 있는 방법도 있다.


- 인터페이스 최소주의 원칙 : 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라는 원칙


- 상위 클래스는 풍성할 수록 좋고(공통 처리), 인터페이스는 작고 종류가 많을수록 좋다.
    - 빈약한 상위 클래스를 사용할 경우, 형변환이 이곳 저곳에서 발생하여 상속의 혜택을 누릴 수 없다.
    - 인터페이스 종류가 많을 수록, 명확해지고 대체 가능성이 높아진다.
    

### 5. DIP : 의존 관계 역전 원칙

- 고차원 모듈은 저차원에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경하는 구체(concrete) 클래스에 의존하지 마라.
 쉽게 말해서 자신보다 변하기 쉬운 것에 의존하지 마라!라는 원칙이다.


- 즉, 클라이언트 코드가 구현 클래스(구체적)에 의존하지 말고, 인터페이스(추상)에 의존하라는 의미이다.(의존의 역전, 구체 to 추상)


- OCP와 유사한 느낌이 든다! 


- 상위 클래스일수록, 인터페이스일수록, 추상 클래스일수록 변하지 않을 가능성이 높기에 여기에 의존하라는 의미!

<br><br>

### 정리 - 객체 지향 세계와 SOLID

- SoC(Separation Of Concerns) - 관심사의 분리 : 관심이 같은 것 끼리는 하나의 객체 안으로, 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 
따로 떨어져 서로 영향을 주지 않도록 분리하는 것이다. 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 하나의 패키지에는 하나의 관심사만 들어 있어야 한다는 의미이다.
  

- SoC를 적용하면, SOLID에 도달하게 된다.


- SOLID를 적용하면 소스 파일의 수가 많아지는 경향이 있다. 하지만 이를 통해 유지 / 보수가 쉬워진다. 


- 최종 정리
    - SRP : 한 클래스는 하나의 책임만 가져야 한다. 변경이 있을 때 파급 효과가 적어야 한다.
    - OCP : 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다. 
    - LSP : 서브 타입은 언제나 자신의 기반(슈퍼) 타입으로 교체할 수 있어야 한다.
    - ISP : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
    - DIP : 자신보다 변하기 쉬운 것에 의존하지 마라.
